
    Dieser Anhang wurde am Ende des Projekts nachgereicht. Er enthält Belege für
    durchgeführte Maßnahmen, bzw. falls nicht durchgeführt eine Begründung wieso
    die Durchführung nicht möglich oder nicht erfolgt ist. \\


% ---------------------------------------------------------------------------
% statische Analysetools

\section{Statische Code-Analyse-Tools}

Um eine hohe Code-Qualität sicherzustellen und damit die Wartbarkeit der
Anwendung zu verbessern, wurden statische Analysetools eingesetzt.

\subsection{Checkstyle}

Wir haben das bekannte und beliebte Tool \glqq Checkstyle\grqq~ verwendet, um die Einhaltung von üblichen Richtlinien zum Programmierstil zu überprüfen und durchzusetzen. Diese tragen zu guter Lesbarkeit und geringer Komplexität des Quellcodes bei.

Im folgenden Abschnitt befindet sich ein Report, der erstellt wurde, als begonnen haben, \glqq Checkstyle\grqq~ einzusetzen. Anschließend haben wir alle bereits vorhandenen Warnungen in Commit 5cd67e0aff2b1edd2b42c48fd6b0a36af83a243e \glqq fixes Checkstyle warnings\grqq~ abgearbeitet. Da mit dem Plugin \glqq Checkstyle-IDEA\grqq~ alle Warnungen direkt in unserer Entwicklungsumgebung angezeigt werden, konnten diese ab dann direkt bei der Programmierung behoben werden, sodass der zweite, zum Abschluss des Projektes erstellte, Report leer ist. Ein Screenshot des Plugins mit markierten Fehlern findet sich im Abschnitt nach den Berichten.

Wir haben bei der Checkstyle-Überprüfung auf die Überprüfung verzichtet, ob Felder als private deklariert werden können, da es bei Android eine empfohlene Vorgehensweise ist, einige Felder öffentlich zu deklarieren. Dies sorgt auf mobilen Geräten für mehr Effizienz, da zum Zugreifen auf ein solches Feld keine Methode über einen Call-Stack aufgerufen werden müssen.


\includepdf[pages=1,offset=-0.8cm 0,scale=.8,pagecommand=\subsubsection{Initialer ``Checkstyle''-Report}]{anhang/partials/checkstyle-1.pdf}
\includepdf[pages=2-,offset=-0.8cm 0,scale=.8,pagecommand={}]{anhang/partials/checkstyle-1.pdf}

\includepdf[pages=1,offset=-0.8cm 0,scale=.8,pagecommand=\subsubsection{Finaler ``Checkstyle''-Report}]{anhang/partials/checkstyle-2.pdf}
\includepdf[pages=2-,offset=-0.8cm 0,scale=.8,pagecommand={}]{anhang/partials/checkstyle-2.pdf}

\subsubsection{Screenshot von Checkstyle-IDEA}

In diesem Screenshot ist sichtbar, wie Checkstyle direkt und insbesondere vor einem Commit Fehler markiert. Hier wird angemerkt, dass zwischen der Typumwandlung \glqq (Peer)\grqq~ und dem Feld \glqq other\grqq~ ein Leerzeichen fehlt, sowie dass die if-else-Konstruktion keine geschweiften Klammern verwendet.

Durch die auffällige rote Markierung kann die Checkstyle-Warnung nicht übersehen werden.

\includegraphics[width=17.5cm]{belege/checkstyle/checkstyle-idea-screenshot.png}


\clearpage
\subsection{Android Lint}

Zusätzlich haben wir das von Google entwickelte und empfohlene ``Android Lint''
genutzt. Dieses Tool gibt Empfehlungen zur Einhaltung der Android-Programmierrichtlinien.

Dadurch verbessert sich einerseits die Wartbarkeit, denn durch das Befolgen der im Android-Umfeld üblichen
 Konventionen und die Verwendung von allgemein bekannten und anerkannten Entwurfsmustern, ist der Code zukünftigen
Entwicklern leichter verständlich.
Andererseits enthalten die Reports Empfehlungen zur Verbesserung der Performance, Usability, Accessibility und Korrektheit.

Im folgenden Abschnitt befindet sich ein Report, der erstellt wurde,
als wir begonnen haben, ``Android Lint'' einzusetzen. Dann wurden initial alle
Warnungen und Empfehlungen abgearbeitet (Commit XXXXXXXXXXXXX TODO).
Die Warnungen und Empfehlungen werden direkt in der von uns verwendeten
Entwicklungsumgebung Android Studio angezeigt, sodass diese anschließend während
der Programmierung direkt umgesetzt werden konnten. Daher ist der zweite Report,
der zum Abschluss des Projekts erstellt wurde, leer.


\includepdf[pages=1,offset=-0.8cm 0,scale=.8,pagecommand=\subsubsection{Initialer ``Android Lint''-Report}]{anhang/partials/lint-results-1.pdf}
\includepdf[pages=2-,offset=-0.8cm 0,scale=.8,pagecommand={}]{anhang/partials/lint-results-1.pdf}

\includepdf[pages=1,offset=-0.8cm 0,scale=.8,pagecommand=\subsubsection{Finaler ``Android Lint''-Report}]{anhang/partials/lint-results-2.pdf}
%\includepdf[pages=2-,scale=.8,pagecommand={}]{anhang/partials/lint-results-2.pdf}


\clearpage
\subsection{FindBugs}

Um häufig auftretende Fehler zu vermeiden, haben wir FindBugs verwendet.

Im folgenden Abschnitt befindet sich ein Report, der erstellt wurde, als wir mit der Verwendung von ``FindBugs'' begonnen aben. Anschließend wurden alle Fehler und Warnungen in Commit XXXXXXXX TODO behoben. Da wir das Plugin FindBugs-IDEA direkt in unsere Entwicklungsumgebung integriert haben und Fehler so direkt markiert wurden, konnten Fehler ab dann direkt bei der Entwicklung vermieden werden und der zweite, am Ende des Projektes erstellte, Report ist leer.


\includepdf[pages=1,offset=-0.8cm 0,scale=.8,pagecommand=\subsubsection{Initialer ``FindBugs''-Report}]{anhang/partials/findbugs-1.pdf}
\includepdf[pages=2-,offset=-0.8cm 0,scale=.8,pagecommand={}]{anhang/partials/findbugs-1.pdf}

\includepdf[pages=1,offset=-0.8cm 0,scale=.8,pagecommand=\subsubsection{Finaler ``FindBugs''-Report}]{anhang/partials/findbugs-2.pdf}
\includepdf[pages=2-,offset=-0.8cm 0,scale=.8,pagecommand={}]{anhang/partials/findbugs-2.pdf}


\clearpage

% ---------------------------------------------------------------------------
% Code Reviews (Einleitung)

\section{Code Reviews}

Zur Sicherstellung der Wartbarkeit durch hohe Code-Qualität wurde bei jedem
Sprint-Treffen mit dem Auftraggeber ein Code Review durchgeführt.

% ---------------------------------------------------------------------------
% Code Reviews: Checkliste

\subsection{Checkliste}

\input{spezifikation/code-review-checklist}

% ---------------------------------------------------------------------------
% Code Reviews: Ergebnisse
\input{anhang/partials/codereviews.tex}


\clearpage
\section{Dokumentation}

Um die Wartung der Anwendung in Zukunft zu erleichtern, wurden die technischen Grundlagen
sowie alle wichtigen Designentscheidungen in einem Dokument festgehalten.

\input{anhang/partials/dokumentation.tex}



% ---------------------------------------------------------------------------
% Automatisierte Tests: (Einleitung)

\clearpage
\section{Automatisierte Tests}

Es wurden JUnit-Tests für die automatisiert testbaren Codeteile durchgeführt.
Im folgenden findet sich zunächst eine Liste aller Tests sowie der Testergebnisse,
außerdem das Ergebnis der Test-Coverage-Analyse, aufgeschlüsselt nach Packages.
\\\\
Wie bereits im QS-Dokument beschrieben, war ein Testen des UI- und Netzwerkcodes
(Packages bonfirechat.network und bonfirechat.ui)
mit dem JUnit-Framework nicht möglich, da die Android-Klassenbibliothek dort nicht
zur Verfügung steht. Das gleiche gilt für die Datenbankklasse, da diese von einer
Android-internen Klasse erbt. Daher konnte auch die Klasse bonfire.data.BonfireData
nicht mit automatisierten Tests versehen werden.
\\\\
Zusammenfassend gilt, dass wir automatisierte Tests für alle Methoden geschrieben haben,
die
\begin{itemize}
\item keine Klassen der Android-Klassenbibliothek verwenden,
\item Klassen der Android-Klassenbibliothek nur als Parameter übergeben bekommen,
sodass wir stattdessen mit Mockito erstellte Mock-Objekte übergeben können, oder
\item mit vertretbarem Aufwand angepasst werden konnten, sodass der vorhergehende Punkt zutrifft.
\end{itemize}

% ---------------------------------------------------------------------------
% Automatisierte Tests: Javadoc-Testplan

\includepdf[pages=1,scale=.8,pagecommand=\subsection{Testplan}]{anhang/partials/javadoc.pdf}
\includepdf[pages=2-,scale=.8,pagecommand={}]{anhang/partials/javadoc.pdf}

% ---------------------------------------------------------------------------
% Automatisierte Tests: Ergebnisse

\includepdf[pages=1,offset=-0.8cm 0,scale=.8,pagecommand=\subsection{Ergebnisse}]{anhang/partials/junit.pdf}
\includepdf[pages=2-,offset=-0.8cm 0,scale=.8,pagecommand={}]{anhang/partials/junit.pdf}


% ---------------------------------------------------------------------------
% Automatisierte Tests: Test Coverage

\includepdf[pages=-,offset=-0.8cm 0,scale=.8,pagecommand=\subsection{Test Coverage}]{anhang/partials/coverage.pdf}



\clearpage

\section{Manuelle Tests der Benutzeroberfläche}

Da uns der Aufwand für die Nutzung eines Instrumented-Test-Frameworks
für das recht einfache User Interface der App unverhältnismäßig
erscheint, werden manuelle Tests anhand der folgenden Testpläne
vorgenommen.

\subsection{Testplan}
\input{belege/manuelle-tests/ui/00-testplan.tex}

\input{anhang/partials/manuelle-tests-ui-reports.tex}


\clearpage
\section{Manueller Test für Routing und Datenübertragungs-Protokolle}
\subsection{Testplan}
\input{belege/manuelle-tests/netzwerk/00-testplan.tex}

\subsection{Durchführung}
\input{belege/manuelle-tests/netzwerk/Netzwerktest-Durchfuehrung.tex}

\section{Großtests}
\subsection{Testplan}
% Add Testplan here \input{}

\subsection{Durchführung}
\input{belege/grosstests/grosstests}
